#include "../shared/util.h"
#include "hashtable.h"
#include <arpa/inet.h>
#include <assert.h>
#include <cassert>
#include <cerrno>
#include <errno.h>
#include <fcntl.h>
#include <netinet/ip.h>
#include <poll.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <string>
#include <sys/event.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
#include <vector>

#define container_of(ptr, T, member) \
    ((T *)( (char *)ptr - offsetof(T, member) ))

constexpr auto k_max_msg = Util::k_max_msg_server;
constexpr auto k_max_args = Util::k_max_args;
constexpr auto &write_all = Util::write_all;
constexpr auto &read_full = Util::read_full;

static void msg(const char *msg) { fprintf(stderr, "%s\n", msg); }

static void die(const char *msg) {
  int err = errno;
  fprintf(stderr, "[%d] %s\n", err, msg);
  abort();
}

static void msg_errno(const char *msg) {
  fprintf(stderr, "[errno:%d] %s\n", errno, msg);
}

static void fd_set_nb(int fd) {
  errno = 0;
  int flags = fcntl(fd, F_GETFL, 0);
  if (errno) {
    die("fcntl error");
    return;
  }

  flags |= O_NONBLOCK;

  errno = 0;
  (void)fcntl(fd, F_SETFL, flags);
  if (errno) {
    die("fcntl error");
  }
}

struct Conn {
  int fd = -1;
  // application's intention, for the event loop
  bool want_read = false;
  bool want_write = false;
  bool want_close = false;
  // buffered input and output
  std::vector<uint8_t> incoming; // data to be parsed by the application
  std::vector<uint8_t> outgoing; // responses generated by the application
};

// append to the back
static void buf_append(std::vector<uint8_t> &buf, const uint8_t *data,
                       size_t len) {
  buf.insert(buf.end(), data, data + len);
}

// remove from the front
static void buf_consume(std::vector<uint8_t> &buf, size_t n) {
  buf.erase(buf.begin(), buf.begin() + n);
}

// application callback when the listening socket is ready
static Conn *handle_accept(int fd) {
  // accept
  struct sockaddr_in client_addr = {};
  socklen_t socklen = sizeof(client_addr);
  int connfd = accept(fd, (struct sockaddr *)&client_addr, &socklen);
  if (connfd < 0) {
    msg_errno("accept() error");
    return NULL;
  }
  uint32_t ip = client_addr.sin_addr.s_addr;
  fprintf(stdout, "new client from %u.%u.%u.%u:%u\n", ip & 255, (ip >> 8) & 255,
          (ip >> 16) & 255, ip >> 24, ntohs(client_addr.sin_port));

  // set the new connection fd to nonblocking mode
  fd_set_nb(connfd);

  // create a `struct Conn`
  Conn *conn = new Conn();
  conn->fd = connfd;
  conn->want_read = true;
  return conn;
}

static bool read_u32(const uint8_t *&cur, const uint8_t *end, uint32_t &out) {
  if (cur + 4 > end) {
    return false;
  }
  memcpy(&out, cur, 4);
  cur += 4;
  return true;
}

static bool read_str(const uint8_t *&cur, const uint8_t *end, size_t n,
                     std::string &out) {
  if (cur + n > end) {
    return false;
  }
  out.assign(cur, cur + n);
  cur += n;
  return true;
}

// +------+-----+------+-----+------+-----+-----+------+
// | nstr | len | str1 | len | str2 | ... | len | strn |
// +------+-----+------+-----+------+-----+-----+------+
static int32_t parse_req(const uint8_t *data, size_t size,
                         std::vector<std::string> &out) {
  const uint8_t *end = data + size;
  uint32_t nstr = 0;
  if (!read_u32(data, end, nstr)) {
    return -1;
  }
  if (nstr > k_max_args) {
    return -1; // safety limit
  }

  while (out.size() < nstr) {
    uint32_t len = 0;
    if (!read_u32(data, end, len)) {
      return -1;
    }
    out.push_back(std::string());
    if (!read_str(data, end, len, out.back())) {
      return -1;
    }
  }
  if (data != end) {
    return -1; // trailing garbage
  }
  return 0;
}

// +--------+---------+
// | status | data... |
// +--------+---------+
struct Response {
  uint32_t status = 0;
  std::vector<uint8_t> data;
};

// global states
static struct {
  HMap db; // top-level hashtable
} g_data;

// KV pair for the top-level hashtable
struct Entry {
  struct HNode node; // hashtable node
  std::string key;
  std::string val;
};

// equality comparison for `struct Entry`
static bool entry_eq(HNode *lhs, HNode *rhs) {
  struct Entry *le = container_of(lhs, struct Entry, node);
  struct Entry *re = container_of(rhs, struct Entry, node);
  return le->key == re->key;
}

// FNV hash
static uint64_t str_hash(const uint8_t *data, size_t len) {
  uint32_t h = 0x811C9DC5;
  for (size_t i = 0; i < len; i++) {
    h = (h + data[i]) * 0x01000193;
  }
  return h;
}

static void do_get(std::vector<std::string> &cmd, Response &out) {
  // a dummy `Entry` just for the lookup
  Entry key;
  key.key.swap(cmd[1]);
  key.node.hcode = str_hash((uint8_t *)key.key.data(), key.key.size());
  // hashtable lookup
  HNode *node = hm_lookup(&g_data.db, &key.node, &entry_eq);
  if (!node) {
    out.status = RES_NX;
    return;
  }
  // copy the value
  const std::string &val = container_of(node, Entry, node)->val;
  assert(val.size() <= k_max_msg);
  out.data.assign(val.begin(), val.end());
}

static void do_set(std::vector<std::string> &cmd, Response &) {
  // a dummy `Entry` just for the lookup
  Entry key;
  key.key.swap(cmd[1]);
  key.node.hcode = str_hash((uint8_t *)key.key.data(), key.key.size());
  // hashtable lookup
  HNode *node = hm_lookup(&g_data.db, &key.node, &entry_eq);
  if (node) {
    // found, update the value
    container_of(node, Entry, node)->val.swap(cmd[2]);
  } else {
    // not found, allocate & insert a new pair
    Entry *ent = new Entry();
    ent->key.swap(key.key);
    ent->node.hcode = key.node.hcode;
    ent->val.swap(cmd[2]);
    hm_insert(&g_data.db, &ent->node);
  }
}

static void do_del(std::vector<std::string> &cmd, Response &) {
  // a dummy `Entry` just for the lookup
  Entry key;
  key.key.swap(cmd[1]);
  key.node.hcode = str_hash((uint8_t *)key.key.data(), key.key.size());
  // hashtable delete
  HNode *node = hm_delete(&g_data.db, &key.node, &entry_eq);
  if (node) { // deallocate the pair
    delete container_of(node, Entry, node);
  }
}

static void make_response(const Response &resp, std::vector<uint8_t> &out) {
  uint32_t resp_len = 4 + (uint32_t)resp.data.size();
  buf_append(out, (const uint8_t *)&resp_len, 4);
  buf_append(out, (const uint8_t *)&resp.status, 4);
  buf_append(out, resp.data.data(), resp.data.size());
}

static void do_request(std::vector<std::string> &cmd, Response &out) {
  if (cmd.size() == 2 && cmd[0] == "get") {
    return do_get(cmd, out);
  } else if (cmd.size() == 3 && cmd[0] == "set") {
    return do_set(cmd, out);
  } else if (cmd.size() == 2 && cmd[0] == "del") {
    return do_del(cmd, out);
  } else {
    out.status = RES_ERR; // unrecognized command
  }
}

// process 1 request if there is enough data
static bool try_one_request(Conn *conn) {
  // try to parse the protocol: message header
  if (conn->incoming.size() < 4) {
    return false; // want read
  }
  uint32_t len = 0;
  memcpy(&len, conn->incoming.data(), 4);
  if (len > k_max_msg) {
    msg("too long");
    conn->want_close = true;
    return false; // want close
  }
  // message body
  if (4 + len > conn->incoming.size()) {
    return false; // want read
  }
  const uint8_t *request = &conn->incoming[4];

  // got one request, do some application logic
  std::vector<std::string> cmd;
  if (parse_req(request, len, cmd) < 0) {
    msg("bad request");
    conn->want_close = true;
    return false; // want close
  }
  Response resp;
  do_request(cmd, resp);
  make_response(resp, conn->outgoing);

  // application logic done! remove the request message.
  buf_consume(conn->incoming, 4 + len);
  // Q: Why not just empty the buffer? See the explanation of "pipelining".
  return true; // success
}

// application callback when the socket is writable
static void handle_write(Conn *conn) {
  assert(conn->outgoing.size() > 0);
  ssize_t rv = write(conn->fd, &conn->outgoing[0], conn->outgoing.size());
  if (rv < 0 && errno == EAGAIN) {
    return; // actually not ready
  }
  if (rv < 0) {
    msg_errno("write() error");
    conn->want_close = true; // error handling
    return;
  }

  // remove written data from `outgoing`
  buf_consume(conn->outgoing, (size_t)rv);

  // update the readiness intention
  if (conn->outgoing.size() == 0) { // all data written
    conn->want_read = true;
    conn->want_write = false;
  } // else: want write
}

// application callback when the socket is readable
static void handle_read(Conn *conn) {
  // read some data
  uint8_t buf[64 * 1024];
  ssize_t rv = read(conn->fd, buf, sizeof(buf));
  if (rv < 0 && errno == EAGAIN) {
    return; // actually not ready
  }
  // handle IO error
  if (rv < 0) {
    msg_errno("read() error");
    conn->want_close = true;
    return; // want close
  }
  // handle EOF
  if (rv == 0) {
    if (conn->incoming.size() == 0) {
      msg("client closed");
    } else {
      msg("unexpected EOF");
    }
    conn->want_close = true;
    return; // want close
  }
  // got some new data
  buf_append(conn->incoming, buf, (size_t)rv);

  // parse requests and generate responses
  while (try_one_request(conn)) {
  }
  // Q: Why calling this in a loop? See the explanation of "pipelining".

  // update the readiness intention
  if (conn->outgoing.size() > 0) { // has a response
    conn->want_read = false;
    conn->want_write = true;
    // The socket is likely ready to write in a request-response protocol,
    // try to write it without waiting for the next iteration.
    return handle_write(conn);
  } // else: want read
}

// Function to update kqueue event subscriptions
static void update_events(int fd, Conn *conn, int kq) {
  struct kevent evSet[2];
  int nev = 0;

  // Always monitor for errors
  EV_SET(&evSet[nev++], fd, EVFILT_READ,
         EV_ADD | (conn->want_read ? EV_ENABLE : EV_DISABLE), 0, 0, conn);
  EV_SET(&evSet[nev++], fd, EVFILT_WRITE,
         EV_ADD | (conn->want_write ? EV_ENABLE : EV_DISABLE), 0, 0, conn);

  if (kevent(kq, evSet, nev, NULL, 0, NULL) == -1) {
    perror("kevent");
    exit(1);
  }
}

int main() {
  // the listening socket
  int listen_fd = socket(AF_INET, SOCK_STREAM, 0);
  if (listen_fd < 0) {
    die("socket()");
  }
  int val = 1;
  setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val));

  // bind
  struct sockaddr_in addr = {};
  addr.sin_family = AF_INET;
  addr.sin_port = ntohs(1234);
  addr.sin_addr.s_addr = ntohl(0); // wildcard address 0.0.0.0
  int rv = bind(listen_fd, (const sockaddr *)&addr, sizeof(addr));
  if (rv) {
    die("bind()");
  }

  // set the listen fd to nonblocking mode
  fd_set_nb(listen_fd);

  // listen
  rv = listen(listen_fd, SOMAXCONN);
  if (rv) {
    die("listen()");
  }

  // Create kqueue
  int kq = kqueue();
  if (kq == -1) {
    perror("kqueue");
    return 1;
  }

  // Create event for listening socket
  struct kevent evSet;
  EV_SET(&evSet, listen_fd, EVFILT_READ, EV_ADD | EV_ENABLE, 0, 0, NULL);
  if (kevent(kq, &evSet, 1, NULL, 0, NULL) == -1) {
    perror("kevent");
    return 1;
  }

  // a map of all client connections, keyed by fd
  std::vector<Conn *> fd2conn; // using vector for performance reasons
  // the event loop
  while (true) {
    struct kevent events[64];
    int nev = kevent(kq, NULL, 0, events, 64, NULL);
    if (nev < 0) {
      if (errno == EINTR)
        continue;
      perror("kevent");
      break;
    }

    for (int i = 0; i < nev; i++) {
      int fd = events[i].ident;
      int filter = events[i].filter;

      if (fd == listen_fd && filter == EVFILT_READ) {
        // Accept new connection
        Conn *conn = handle_accept(listen_fd);
        if (conn) {
          if ((size_t)conn->fd >= fd2conn.size()) {
            fd2conn.resize(conn->fd + 1);
          }
          fd2conn[conn->fd] = conn;
          update_events(conn->fd, conn, kq);
        }
      } else {
        // Handle client connections
        Conn *conn = fd2conn[fd];
        if (!conn)
          continue;

        if (filter == EVFILT_READ) {
          handle_read(conn);
        }
        if (filter == EVFILT_WRITE) {
          handle_write(conn);
        }

        if (conn->want_close) {
          close(fd);
          fd2conn[fd] = nullptr;
          delete conn;
        } else {
          update_events(fd, conn, kq);
        }
      }
    }
  }
  close(kq);
  return 0;
}
